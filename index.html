<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netanyahu Paraglider Attack</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            touch-action: none;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        let gameState = 'playing';
        let score = 0;
        let lives = 3;
        let cameraX = 0;
        let groundY;
        let frame = 0;
        let lastSpawnDist = 0;

        const player = {
            x: 200,
            y: 0,
            width: 40,
            height: 60,
            vx: 0,
            vy: 0,
            onGround: false,
            shootCooldown: 0
        };

        let bullets = [];
        let enemies = [];

        // Input
        const keys = {};
        const pointer = { x: 0, y: 0, isDown: false, id: -1 };
        let aimX = 0;
        let aimY = 0;
        let shooting = false;
        let leftPressed = false;
        let rightPressed = false;
        let jumpPressed = false;

        // Button positions (fixed for simplicity)
        const buttonY = () => canvas.height - 100;
        const buttonLeftX = 30;
        const buttonJumpX = 110;
        const buttonRightX = 190;
        const buttonW = 60;
        const buttonH = 60;

        // Event listeners
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        canvas.addEventListener('pointerdown', handlePointerDown);
        canvas.addEventListener('pointermove', handlePointerMove);
        canvas.addEventListener('pointerup', handlePointerUp);
        canvas.addEventListener('pointercancel', handlePointerUp);
        canvas.addEventListener('pointerleave', handlePointerUp);

        function handlePointerDown(e) {
            e.preventDefault();
            if (pointer.id !== -1) return;
            pointer.id = e.pointerId;
            pointer.isDown = true;
            updatePointerPos(e);
        }

        function handlePointerMove(e) {
            if (e.pointerId !== pointer.id) return;
            updatePointerPos(e);
        }

        function handlePointerUp(e) {
            if (e.pointerId !== pointer.id) return;
            pointer.id = -1;
            pointer.isDown = false;
        }

        function updatePointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            pointer.x = ((e.clientX - rect.left) / rect.width) * canvas.width;
            pointer.y = ((e.clientY - rect.top) / rect.height) * canvas.height;
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function updateInput() {
            // Keyboard
            leftPressed = keys['a'] || keys['arrowleft'];
            rightPressed = keys['d'] || keys['arrowright'];
            jumpPressed = keys['w'] || keys[' '] || keys['arrowup'];

            // Pointer controls (mobile/buttons)
            if (pointer.isDown && pointer.x < canvas.width * 0.5) {
                // Check buttons
                const by = buttonY();
                leftPressed = leftPressed || (pointer.x >= buttonLeftX && pointer.x <= buttonLeftX + buttonW &&
                                             pointer.y >= by && pointer.y <= by + buttonH);
                jumpPressed = jumpPressed || (pointer.x >= buttonJumpX && pointer.x <= buttonJumpX + buttonW &&
                                             pointer.y >= by && pointer.y <= by + buttonH);
                rightPressed = rightPressed || (pointer.x >= buttonRightX && pointer.x <= buttonRightX + buttonW &&
                                               pointer.y >= by && pointer.y <= by + buttonH);
            }

            // Aim and shoot (right side)
            if (pointer.isDown && pointer.x >= canvas.width / 3) {
                aimX = pointer.x;
                aimY = pointer.y;
                shooting = true;
            } else {
                shooting = false;
            }
        }

        function updatePlayer() {
            updateInput();

            // Movement
            if (leftPressed) player.vx = Math.max(player.vx - 0.6, -6);
            if (rightPressed) player.vx = Math.min(player.vx + 0.6, 6);
            if (jumpPressed && player.onGround) {
                player.vy = -14;
                player.onGround = false;
            }

            // Physics
            player.vy += 0.8;
            player.vx *= 0.88;
            player.x += player.vx;
            player.y += player.vy;

            player.x = Math.max(0, player.x);

            // Ground collision
            groundY = canvas.height - 120;
            if (player.y + player.height > groundY) {
                player.y = groundY - player.height;
                player.vy = 0;
                player.onGround = true;
            }

            // Shooting
            if (shooting && player.shootCooldown <= 0) {
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                const aimWorldX = cameraX + aimX;
                const aimWorldY = aimY;
                const dx = aimWorldX - playerCenterX;
                const dy = aimWorldY - playerCenterY;
                const dist = Math.hypot(dx, dy);
                if (dist > 10) {  // Avoid self-shoot
                    bullets.push({
                        x: playerCenterX,
                        y: playerCenterY,
                        vx: (dx / dist) * 12,
                        vy: (dy / dist) * 12,
                        isPlayer: true,
                        width: 5,
                        height: 5
                    });
                    player.shootCooldown = 6;
                }
            }
            if (player.shootCooldown > 0) player.shootCooldown--;
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.vx;
                b.y += b.vy;

                // Remove offscreen
                if (b.x < cameraX - 100 || b.x > cameraX + canvas.width + 100 ||
                    b.y < -100 || b.y > canvas.height + 100) {
                    bullets.splice(i, 1);
                }
            }
        }

        function updateEnemies() {
            // Spawn
            if (player.x > lastSpawnDist + 700 + Math.random() * 500) {
                enemies.push({
                    x: cameraX + canvas.width + Math.random() * 200,
                    y: groundY - 250 - Math.random() * 150,
                    width: 50,
                    height: 70,
                    vx: -2.5 - Math.random() * 1,
                    phase: Math.random() * Math.PI * 2,
                    shootCooldown: 0,
                    health: 2,
                    colorHue: 120 + Math.random() * 60  // Greenish
                });
                lastSpawnDist = player.x;
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.x += e.vx;
                e.y += Math.sin(frame * 0.015 + e.phase) * 1.2;

                // Enemy shooting
                if (e.shootCooldown <= 0) {
                    const playerCenterX = player.x + player.width / 2;
                    const playerCenterY = player.y + player.height / 2;
                    const dx = playerCenterX - (e.x + e.width / 2);
                    const dy = playerCenterY - (e.y + e.height / 2);
                    const dist = Math.hypot(dx, dy);
                    if (dist > 50) {
                        bullets.push({
                            x: e.x + e.width / 2,
                            y: e.y + e.height / 2,
                            vx: (dx / dist) * 7,
                            vy: (dy / dist) * 7,
                            isPlayer: false,
                            width: 4,
                            height: 4
                        });
                        e.shootCooldown = 80 + Math.random() * 40;
                    }
                } else {
                    e.shootCooldown--;
                }

                // Remove passed enemies
                if (e.x + e.width < player.x - 200) {
                    enemies.splice(i, 1);
                    lives = Math.max(0, lives - 1);
                }
            }
        }

        function checkCollisions() {
            // Player bullets hit enemies
            for (let bi = bullets.length - 1; bi >= 0; bi--) {
                const b = bullets[bi];
                if (!b.isPlayer) continue;
                for (let ei = enemies.length - 1; ei >= 0; ei--) {
                    const e = enemies[ei];
                    if (b.x > e.x && b.x < e.x + e.width &&
                        b.y > e.y && b.y < e.y + e.height) {
                        e.health--;
                        bullets.splice(bi, 1);
                        if (e.health <= 0) {
                            enemies.splice(ei, 1);
                            score += 100;
                        }
                        break;
                    }
                }
            }

            // Enemy bullets hit player
            for (let bi = bullets.length - 1; bi >= 0; bi--) {
                const b = bullets[bi];
                if (b.isPlayer) continue;
                const px = player.x;
                const py = player.y;
                if (b.x > px && b.x < px + player.width &&
                    b.y > py && b.y < py + player.height) {
                    bullets.splice(bi, 1);
                    lives = Math.max(0, lives - 1);
                }
            }
        }

        function updateCamera() {
            cameraX = Math.max(0, player.x + player.width / 2 - canvas.width * 0.4);
        }

        function updateGame() {
            updatePlayer();
            updateBullets();
            updateEnemies();
            checkCollisions();
            updateCamera();
            if (lives <= 0) gameState = 'gameover';
        }

        function drawBG() {
            // Sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, groundY);
            skyGrad.addColorStop(0, '#87CEEB');
            skyGrad.addColorStop(0.7, '#B0E0E6');
            skyGrad.addColorStop(1, '#E0FFFF');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, canvas.width, groundY);

            // Ground
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Scrolling grass
            ctx.strokeStyle = '#32CD32';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            const grassSpacing = 35;
            for (let i = 0; i < canvas.width * 1.5; i += grassSpacing) {
                const gx = (i - (cameraX % grassSpacing)) % canvas.width;
                ctx.beginPath();
                ctx.moveTo(gx, groundY);
                ctx.lineTo(gx + 8, groundY - 18);
                ctx.lineTo(gx + 18, groundY);
                ctx.stroke();
            }
        }

        function drawPlayer() {
            const screenX = player.x - cameraX;
            const screenY = player.y;
            ctx.save();
            ctx.translate(screenX + player.width / 2, screenY + player.height / 2);

            // Suit
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(-player.width / 2 + 4, player.height / 2 - 45, player.width - 8, 45);

            // Tie
            ctx.fillStyle = '#DC143C';
            ctx.fillRect(-4, player.height / 2 - 40, 8, 18);

            // Head
            ctx.fillStyle = '#FDBCB4';
            ctx.beginPath();
            ctx.arc(0, player.height / 2 - 55, 16, 0, Math.PI * 2);
            ctx.fill();

            // Hair (white, combed back)
            ctx.fillStyle = '#F0F0F0';
            ctx.beginPath();
            ctx.arc(3, player.height / 2 - 55, 17, Math.PI * 0.6, Math.PI * 1.4);
            ctx.fill();

            // Eyebrows
            ctx.fillStyle = '#000';
            ctx.fillRect(-10, player.height / 2 - 48, 8, 2);
            ctx.fillRect(2, player.height / 2 - 48, 8, 2);

            // Eyes
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(-6, player.height / 2 - 50, 3, 0, Math.PI * 2);
            ctx.arc(6, player.height / 2 - 50, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#1E90FF';
            ctx.beginPath();
            ctx.arc(-6, player.height / 2 - 51, 1.5, 0, Math.PI * 2);
            ctx.arc(6, player.height / 2 - 51, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Mouth
            ctx.fillStyle = '#FDBCB4';
            ctx.beginPath();
            ctx.arc(0, player.height / 2 - 42, 5, 0, Math.PI);
            ctx.fill();

            ctx.restore();
        }

        function drawEnemy(e) {
            const screenX = e.x - cameraX;
            const screenY = e.y;
            if (screenX < -e.width || screenX > canvas.width + 100) return;
            ctx.save();
            ctx.translate(screenX + e.width / 2, screenY + e.height / 2);

            // Paraglider canopy
            ctx.fillStyle = `hsl(${e.colorHue}, 60%, 55%)`;
            ctx.beginPath();
            ctx.ellipse(0, -30, 28, 15, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Strings
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-18, -15);
            ctx.lineTo(-8, 5);
            ctx.moveTo(0, -15);
            ctx.lineTo(0, 18);
            ctx.moveTo(18, -15);
            ctx.lineTo(8, 5);
            ctx.stroke();

            // Pilot body
            ctx.fillStyle = '#556B2F';  // Olive green
            ctx.fillRect(-4, 5, 8, 25);

            // Pilot head
            ctx.fillStyle = '#D2B48C';
            ctx.beginPath();
            ctx.arc(0, -10, 5, 0, Math.PI * 2);
            ctx.fill();

            // Mask/scarf
            ctx.fillStyle = '#228B22';
            ctx.fillRect(-3.5, -13, 7, 6);

            ctx.restore();
        }

        function drawBullets() {
            for (const b of bullets) {
                const sx = b.x - cameraX;
                const sy = b.y;
                ctx.save();
                ctx.translate(sx, sy);
                ctx.fillStyle = b.isPlayer ? '#FFD700' : '#FF4500';
                ctx.shadowColor = b.isPlayer ? '#FFD700' : '#FF4500';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(0, 0, b.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }

        function drawUI() {
            // Score and lives
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 4;
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score}`, 30, 65);
            ctx.textAlign = 'right';
            ctx.fillText(`Lives: ${lives}`, canvas.width - 30, 65);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'left';

            // Control buttons (always visible, smaller on desktop)
            const by = buttonY();
            // Left
            ctx.fillStyle = leftPressed ? '#FFFF88' : '#666666';
            ctx.fillRect(buttonLeftX, by, buttonW, buttonH);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 45px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('←', buttonLeftX + buttonW / 2, by + buttonH / 2);
            // Jump
            ctx.fillStyle = jumpPressed ? '#FFFF88' : '#666666';
            ctx.fillRect(buttonJumpX, by, buttonW, buttonH);
            ctx.fillText('↑', buttonJumpX + buttonW / 2, by + buttonH / 2);
            // Right
            ctx.fillStyle = rightPressed ? '#FFFF88' : '#666666';
            ctx.fillRect(buttonRightX, by, buttonW, buttonH);
            ctx.fillText('→', buttonRightX + buttonW / 2, by + buttonH / 2);

            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
            ctx.font = '24px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillText('Touch/Mouse right: Aim & Shoot', 280, canvas.height - 30);
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'white';
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 40);

            ctx.font = 'bold 48px Arial';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);

            ctx.font = 'bold 36px Arial';
            ctx.fillText('Click/Tap anywhere to Restart', canvas.width / 2, canvas.height / 2 + 110);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'left';
        }

        function resetGame() {
            player.x = 200;
            player.y = groundY - player.height;
            player.vx = 0;
            player.vy = 0;
            player.onGround = true;
            player.shootCooldown = 0;
            bullets = [];
            enemies = [];
            score = 0;
            lives = 3;
            cameraX = 0;
            lastSpawnDist = 0;
            frame = 0;
            gameState = 'playing';
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            groundY = canvas.height - 120;

            if (gameState === 'playing') {
                updateGame();
            } else {
                drawGameOver();
                if (pointer.isDown) {
                    resetGame();
                }
            }

            drawBG();
            drawBullets();
            enemies.forEach(drawEnemy);
            drawPlayer();
            drawUI();

            frame++;
            requestAnimationFrame(gameLoop);
        }

        // Start
        resizeCanvas();
        gameLoop();
    </script>
</body>
</html>