<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Me vs God: The Awakening</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a0f2e; touch-action: none; font-family: 'Arial Black', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px; color: #fff;
            font-size: 20px; pointer-events: none;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
        }
    </style>
</head>
<body>

<div id="ui">
    Divine Wrath Survived: <span id="score">0</span> | Mortal Shell Integrity: <span id="health">100</span>%
</div>
<canvas id="gameCanvas"></canvas>

<script>
    // --- ASSET LOADING ---
    const playerSprite = new Image();
    // IMPORTANT: This file must exist next to index.html
    playerSprite.src = 'image_0.png'; 
    let assetsLoaded = false;
    playerSprite.onload = () => { assetsLoaded = true; console.log("Hero loaded!"); };
    playerSprite.onerror = () => { console.error("Could not load image_0.png. Check file name and location."); };


    // --- SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const healthEl = document.getElementById('health');

    let width, height;
    
    // --- THE MAP ---
    // Platforms are simple rectangles: x, y, width, height
    let platforms = [];

    function createMap() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        
        platforms = [
            // The Ground
            {x: 0, y: height - 30, w: width, h: 30, color: '#2a1f3e'},
            // Lower platforms
            {x: width * 0.1, y: height * 0.75, w: width * 0.2, h: 20, color: '#4a3f5e'},
            {x: width * 0.7, y: height * 0.75, w: width * 0.2, h: 20, color: '#4a3f5e'},
            // Middle platforms
            {x: width * 0.3, y: height * 0.5, w: width * 0.4, h: 20, color: '#6a5f7e'},
            // High perch
            {x: width * 0.1, y: height * 0.25, w: width * 0.15, h: 20, color: '#8a7f9e'},
            {x: width * 0.75, y: height * 0.25, w: width * 0.15, h: 20, color: '#8a7f9e'}
        ];
        
        // Reset player position on resize so they don't fall through the world
        if(player) { player.x = width/2; player.y = 0; }
    }
    window.addEventListener('resize', createMap);
    createMap(); // Initial call

    // --- GAME STATE ---
    let score = 0;
    let gameActive = true;
    const gravity = 0.5; // Slightly floatier feel
    const friction = 0.85;

    // --- INPUTS ---
    const keys = { w: false, a: false, d: false };
    const mouse = { x: width/2, y: height/2, down: false };

    window.addEventListener('keydown', e => {
        if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = true;
        if(e.key === 'd' || e.key === 'ArrowRight') keys.d = true;
        if(e.key === 'w' || e.key === ' ' || e.key === 'ArrowUp') keys.w = true;
    });
    window.addEventListener('keyup', e => {
        if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = false;
        if(e.key === 'd' || e.key === 'ArrowRight') keys.d = false;
        if(e.key === 'w' || e.key === ' ' || e.key === 'ArrowUp') keys.w = false;
    });
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', () => mouse.down = true);
    window.addEventListener('mouseup', () => mouse.down = false);
    
    // Touch handling (simplified for space, works similar to before)
    window.addEventListener('touchstart', handleTouch, {passive: false});
    window.addEventListener('touchmove', handleTouch, {passive: false});
    window.addEventListener('touchend', e => { if (e.touches.length === 0) { keys.a=false; keys.d=false; keys.w=false; mouse.down=false; } });
    function handleTouch(e) {
        e.preventDefault();
        keys.a=false; keys.d=false; keys.w=false; mouse.down=false;
        for (let i = 0; i < e.touches.length; i++) {
            const t = e.touches[i];
            if (t.clientX < width / 2) {
                if (t.clientX < width / 4) keys.a = true; else keys.d = true;
                if (t.clientY < height / 2) keys.w = true;
            } else { mouse.x = t.clientX; mouse.y = t.clientY; mouse.down = true; }
        }
    }

    // --- CLASSES ---

    class Player {
        constructor() {
            // Size of your character box
            this.w = 50;
            this.h = 70; 
            this.x = width / 2;
            this.y = height - 200;
            this.vx = 0;
            this.vy = 0;
            this.speed = 1.5; // Acceleration
            this.jumpStrength = 16;
            this.hp = 100;
            this.grounded = false;
        }

        update() {
            // Horizontal movement
            if (keys.a) this.vx -= this.speed;
            if (keys.d) this.vx += this.speed;
            this.vx *= friction;
            this.x += this.vx;

            // Gravity always applies
            this.vy += gravity;
            this.y += this.vy;

            this.grounded = false;

            // --- Platform Collision (The tricky part!) ---
            for (const plat of platforms) {
                // Check if player's bounding box overlaps platform
                if (this.x < plat.x + plat.w &&
                    this.x + this.w > plat.x &&
                    this.y < plat.y + plat.h &&
                    this.y + this.h > plat.y) {
                    
                    // Landing on top (only if falling down and feet were above platform before falling)
                    const previousY = this.y - this.vy;
                    if (this.vy > 0 && previousY + this.h <= plat.y + 10) {
                         this.y = plat.y - this.h;
                         this.vy = 0;
                         this.grounded = true;
                    }
                    // Hitting head on bottom
                    else if (this.vy < 0 && previousY >= plat.y + plat.h - 10) {
                         this.y = plat.y + plat.h;
                         this.vy = 0;
                    }
                }
            }

            // Jump only if on a platform
            if (keys.w && this.grounded) {
                this.vy = -this.jumpStrength;
                this.grounded = false;
            }

            // Screen boundaries
            if (this.x < 0) this.x = 0;
            if (this.x + this.w > width) this.x = width - this.w;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x + this.w/2, this.y + this.h/2);

            // Facing direction
            if (mouse.x < this.x) ctx.scale(-1, 1);

            if (assetsLoaded) {
                // Draw YOUR photo!
                // We draw it slightly larger than the hitbox for personality
                ctx.drawImage(playerSprite, -this.w/2 - 10, -this.h/2 - 10, this.w + 20, this.h + 20);
            } else {
                // Fallback placeholder if image fails
                ctx.fillStyle = 'green';
                ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
            }
            
            // The "Gun" (simple line for now, we'll enhance later)
            const angle = Math.atan2(mouse.y - (this.y + this.h/3), mouse.x - (this.x + this.w/2));
            if (mouse.x < this.x) ctx.scale(-1, 1); // un-flip for accurate aiming angle
            ctx.rotate(angle);
            ctx.fillStyle = '#333';
            ctx.fillRect(0, -5, 40, 10); 

            ctx.restore();
        }
    }

    // Reusing simpler bullets for now
    class Bullet {
        constructor(x, y, angle, isEnemy) {
            this.x = x; this.y = y; this.isEnemy = isEnemy;
            this.speed = isEnemy ? 8 : 15;
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
            this.active = true;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            if (this.x<0 || this.x>width || this.y<0 || this.y>height) this.active = false;
        }
        draw() {
            ctx.beginPath(); ctx.arc(this.x, this.y, this.isEnemy?5:3, 0, Math.PI*2);
            ctx.fillStyle = this.isEnemy ? '#ff4444' : '#ffff00'; ctx.fill();
        }
    }

    // Placeholder for "Angels"
    class Angel Enemy {
        constructor(isGod = false) {
            this.isGod = isGod;
            this.w = isGod ? 100 : 40;
            this.h = isGod ? 100 : 40;
            this.x = Math.random() < 0.5 ? -150 : width + 150;
            this.y = Math.random() * (height / 3); // They stay high
            this.vx = (width/2 - this.x) / (isGod ? 400 : 200);
            this.vy = Math.sin(Date.now()/500) * 2;
            this.active = true;
            this.hp = isGod ? 50 : 3;
            this.lastShot = 0;
            this.shotDelay = isGod ? 1000 : 2500;
        }
        update() {
            this.x += this.vx; this.y += Math.sin(Date.now() / (this.isGod? 800:500)) * (this.isGod?0.5:1.5);
            if (this.x < -200 || this.x > width + 200) this.vx *= -1;

            const now = Date.now();
            if (now - this.lastShot > this.shotDelay) {
                this.lastShot = now;
                // Aim at player center
                const angle = Math.atan2((player.y + player.h/2) - (this.y + this.h/2), (player.x + player.w/2) - (this.x + this.w/2));
                bullets.push(new Bullet(this.x+this.w/2, this.y+this.h/2, angle, true));
            }
        }
        draw() {
            ctx.save();
            ctx.translate(this.x + this.w/2, this.y + this.h/2);
            
            // Placeholder graphics for God/Angels
            if(this.isGod) {
                 // GOD: Big glowing golden circle placeholder
                ctx.shadowBlur = 30; ctx.shadowColor = "gold";
                ctx.fillStyle = '#fffacd'; 
                ctx.beginPath(); ctx.arc(0,0, this.w/2, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                // ANGEL: Smaller cyan winged shape placeholder
                ctx.fillStyle = '#00ffff';
                ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(20, 0); ctx.lineTo(0, 20); ctx.lineTo(-20, 0); ctx.fill();
            }
            ctx.restore();
        }
    }

    // --- MAIN LOOP ---
    const player = new Player();
    let bullets = [];
    let enemies = [];
    let shootTimer = 0;

    function gameLoop() {
        if(!gameActive) return;
        
        // Draw Background Scene
        // Sky gradient
        let grd = ctx.createLinearGradient(0, 0, 0, height);
        grd.addColorStop(0, "#0d001a"); // Dark heavens
        grd.addColorStop(1, "#3a2e5a"); // Horizon
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);

        // Draw Platforms
        for (const p of platforms) {
            ctx.fillStyle = p.color;
            // Add a glowing top edge
            ctx.fillRect(p.x, p.y, p.w, p.h);
            ctx.fillStyle = '#6a5f7e';
            ctx.fillRect(p.x, p.y, p.w, 3);
        }

        player.update();
        player.draw();

        // Player Shooting
        if (mouse.down && Date.now() - shootTimer > 100) {
            shootTimer = Date.now();
            // Offset bullet start to match gun position roughly
            const angle = Math.atan2(mouse.y - (player.y + player.h/3), mouse.x - (player.x + player.w/2));
            bullets.push(new Bullet(player.x + player.w/2, player.y + player.h/3, angle, false));
        }

        // Spawning
        if (enemies.length < 3 + Math.floor(score/1000)) {
            // 10% chance to spawn God boss if score > 2000
            let spawnGod = score > 2000 && Math.random() < 0.1;
            if(enemies.some(e => e.isGod)) spawnGod = false; // Only one God at a time
            enemies.push(new Angel Enemy(spawnGod));
        }

        // Collisions and Updates (Simplified for brevity in this layer)
        updateBulletsAndEnemies();

        requestAnimationFrame(gameLoop);
    }

    function updateBulletsAndEnemies() {
        // --- Bullets vs Enemies ---
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i]; b.update(); b.draw();
            if (!b.active) { bullets.splice(i, 1); continue; }
            
            if (!b.isEnemy) { // Player bullets
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    // Simple hitbox check
                    if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
                        b.active = false; e.hp--;
                        if (e.hp <= 0) {
                            score += e.isGod ? 5000 : 500; scoreEl.innerText = score;
                            enemies.splice(j, 1);
                        }
                    }
                }
            } else { // Enemy bullets hitting player
                if (b.x > player.x+10 && b.x < player.x + player.w-10 && b.y > player.y && b.y < player.y + player.h) {
                     b.active = false; player.hp -= 5; healthEl.innerText = player.hp;
                     if(player.hp <= 0) { gameActive = false; alert("Smited! Score: " + score); location.reload(); }
                }
            }
        }
        // --- Update Enemies ---
        for (let i = enemies.length - 1; i >= 0; i--) { enemies[i].update(); enemies[i].draw(); }
    }

    // Give the image a moment to load before starting
    setTimeout(gameLoop, 500);

</script>
</body>
</html>
